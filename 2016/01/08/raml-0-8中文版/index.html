<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>raml-0.8中文版 | PilockHulmes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RAML&amp;trade;版本0.8: REST风格API的建模语言点击查看新版RAML(1.0)
摘要RAML&amp;trade;是一门基于YAML, 用于描述REST风格API的语言. 在YAML规范的基础上, 本规范提供了用于描述REST风格API, 创建客户端与服务端代码生成器, 以及通过RAML API定义来生成API用户手册所需的一切信息;
简介本规范介绍了RAML. RAML定义了一种可同时供">
<meta property="og:type" content="article">
<meta property="og:title" content="raml-0.8中文版">
<meta property="og:url" content="http://yoursite.com/2016/01/08/raml-0-8中文版/index.html">
<meta property="og:site_name" content="PilockHulmes">
<meta property="og:description" content="RAML&amp;trade;版本0.8: REST风格API的建模语言点击查看新版RAML(1.0)
摘要RAML&amp;trade;是一门基于YAML, 用于描述REST风格API的语言. 在YAML规范的基础上, 本规范提供了用于描述REST风格API, 创建客户端与服务端代码生成器, 以及通过RAML API定义来生成API用户手册所需的一切信息;
简介本规范介绍了RAML. RAML定义了一种可同时供">
<meta property="og:updated_time" content="2016-01-10T08:05:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="raml-0.8中文版">
<meta name="twitter:description" content="RAML&amp;trade;版本0.8: REST风格API的建模语言点击查看新版RAML(1.0)
摘要RAML&amp;trade;是一门基于YAML, 用于描述REST风格API的语言. 在YAML规范的基础上, 本规范提供了用于描述REST风格API, 创建客户端与服务端代码生成器, 以及通过RAML API定义来生成API用户手册所需的一切信息;
简介本规范介绍了RAML. RAML定义了一种可同时供">
  
    <link rel="alternative" href="/atom.xml" title="PilockHulmes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PilockHulmes</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Article Archives</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-raml-0-8中文版" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/08/raml-0-8中文版/" class="article-date">
  <time datetime="2016-01-08T08:06:26.000Z" itemprop="datePublished">2016-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      raml-0.8中文版
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RAML_26trade_3B_u7248_u672C0-8_3A_REST_u98CE_u683CAPI_u7684_u5EFA_u6A21_u8BED_u8A00"><a href="#RAML_26trade_3B_u7248_u672C0-8_3A_REST_u98CE_u683CAPI_u7684_u5EFA_u6A21_u8BED_u8A00" class="headerlink" title="RAML&trade;版本0.8: REST风格API的建模语言"></a>RAML&trade;版本0.8: REST风格API的建模语言</h1><p>点击查看<a href="http://raml.org/spec.html" target="_blank" rel="external">新版RAML(1.0)</a></p>
<h2 id="u6458_u8981"><a href="#u6458_u8981" class="headerlink" title="摘要"></a>摘要</h2><p>RAML&trade;是一门基于YAML, 用于描述REST风格API的语言. 在<a href="http://yaml.org/spec/1.2/spec.html" target="_blank" rel="external">YAML规范</a>的基础上, 本规范提供了用于描述REST风格API, 创建客户端与服务端代码生成器, 以及通过RAML API定义来生成API用户手册所需的一切信息;</p>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>本规范介绍了RAML. RAML定义了一种可同时供人阅读与供机器运行的对REST风格API的描述方式. API文档生成器, API客户端代码生成器与API服务器可通过同一份RAML文档分别生成用户手册, 客户端代码以及服务器代码框架.</p>
<h2 id="u7EA6_u5B9A"><a href="#u7EA6_u5B9A" class="headerlink" title="约定"></a>约定</h2><p>本规范中的”<em>必须</em>“, “<em>必须不</em>“, “<em>要求</em>“, “<em>应</em>“, “<em>不应</em>“, “<em>应该</em>“, “<em>不应该</em>“, “<em>建议</em>“, “<em>或许</em>“和”<em>可选</em>“等关键字的意思遵从 RFC 2119 [RFC2119]中的定义.</p>
<h2 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h2><p>RAML定义了媒体类型”application/raml+yaml”以用于描述并记录诸如methods, schema等REST风格API的资源. RAML基于YAML语言, 且其文档支持所有YAML 1.2的特性. RAML文件的推荐扩展名是”.raml”.</p>
<p>RAML也提供工具来给REST风格API制作详尽的文档, 并允许文档生成工具从中提取信息来将其转换成诸如PDF, HTML等格式的用户手册.</p>
<p>RAML同样引进了resource types(资源类型)和traits(特质)这两种新概念来描述资源和请求, 以期尽可能减少描述REST风格API时的重复工作.</p>
<p>本RAML规范的结构如下:</p>
<ul>
<li><strong>基础信息.</strong> 说明如何描述一份REST风格API的名字, 标题, 位置等核心方面.</li>
<li><strong>用户手册.</strong> 描述如何为REST风格API引用辅助文档.</li>
<li><strong>Resource Types(资源类型)和Traits(特质).</strong> 描述一种使用RAML的resource types(资源类型)与traits(特质)来避免定义REST风格API时重复工作的技巧.</li>
<li><strong>Resource</strong> 描述如何表示REST风格API中的resources, resources的methods和schema, 以及resources之间的交互.</li>
</ul>
<h3 id="u672F_u8BED"><a href="#u672F_u8BED" class="headerlink" title="术语"></a>术语</h3><p>在本规范中将用 <em>API定义</em> 来表示使用本规范定义的API并用 <em>RAML规范</em> 来表示本文档.</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p><em>REST</em> 用于形容一个依照REST原则实现的API. REST是Representational State Transfer(表征状态传输)的缩写, 这个概念最早是在2000年时由Roy Fielding在他的博士毕业论文 [REST] 中提出的.</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>一个 <em>resource</em> 是对一个实体或是实体组的概念映射.</p>
<h2 id="u6807_u8BB0_u8BED_u8A00"><a href="#u6807_u8BB0_u8BED_u8A00" class="headerlink" title="标记语言"></a>标记语言</h2><p>本规范使用YAML 1.2 [YAML]作为核心格式. 作为可供阅读的数据格式, YAML十分符合本规范的设计目标.</p>
<p>RAML API定义文档像YAML文档一样要求以指明RAML版本的YAML注释行作为起始, 举例如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8</span><br></pre></td></tr></table></figure>
<p>RAML版本必须放在RAML文档的第一行. RAML编译器必须将剩余加了YAML注释符号的行视作注释.</p>
<p>在RAML中, YAML原有的数据结构被增强以容纳原本不支持的数据类型. 所有RAML文档必须支持这些扩展.</p>
<p>在RAML中, 所有值都大小写敏感.</p>
<h3 id="u5F15_u5165"><a href="#u5F15_u5165" class="headerlink" title="引入"></a>引入</h3><p>在YAML规范中不要求YAML编译器使用任何方式把一份YAML文件分成更易管理的小份文件. 而RAML文档必须能够被分为多份文件. 为了支持该功能, 所有RAML编译器必须支持 <em>include</em> 标签来引入RAML, YAML和其他常见文本文件.</p>
<p>在本例中, myTextFile.txt中的内容被引入作为external属性的值.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;external: !include myTextFile.txt</span><br></pre></td></tr></table></figure>
<p>当引入RAML或YAML文件时, RAML编辑器不仅要能够读到其中内容, 还要能将其加入到声明结构中, 就像在文档内声明了这些内容一样.</p>
<p>为了简化API定义, 也由于被引入的文件并不与其父级文件共享编译上下文, 因此一份被引入的文件不应使用另一份文件中定义的锚. 同样地, 父级文件中不应使用引入文件中定义的锚</p>
<p>在本例中, <em>properties.raml</em> 文件定义了两个属性. <em>big.raml</em> 引用了properties.raml文件.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;#properties.raml&#10;&#10;propertyA: valueA&#10;propertyB: valueB</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;#big.raml&#10;&#10;external: !include properties.raml</span><br></pre></td></tr></table></figure>
<p>这样子得到的结果和以下内联声明相同:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;external:&#10;  propertyA: valueA&#10;  propertyB: valueB</span><br></pre></td></tr></table></figure>
<p>如果在被引入的文件中使用了相对路径, 该相对路径会基于原(发起引用的)文件的位置来解读. 如果原文件是作为HTTP资源获取到的, 那么被其引入的文件也应高通过HTTP来获取.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/08/raml-0-8中文版/" data-id="cij9tlueh00016g7jbwid0uqt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/01/05/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/08/raml-0-8中文版/">raml-0.8中文版</a>
          </li>
        
          <li>
            <a href="/2016/01/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 PilockHulmes<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>