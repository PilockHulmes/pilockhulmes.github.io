<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>PilockHulmes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="PilockHulmes">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="PilockHulmes">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PilockHulmes">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="PilockHulmes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PilockHulmes</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Article Archives</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-raml-0-8中文版" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/08/raml-0-8中文版/" class="article-date">
  <time datetime="2016-01-08T08:06:26.000Z" itemprop="datePublished">2016-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/08/raml-0-8中文版/">raml-0.8中文版</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="RAML_26trade_3B_u7248_u672C0-8_3A_REST_u98CE_u683CAPI_u7684_u5EFA_u6A21_u8BED_u8A00"><a href="#RAML_26trade_3B_u7248_u672C0-8_3A_REST_u98CE_u683CAPI_u7684_u5EFA_u6A21_u8BED_u8A00" class="headerlink" title="RAML&trade;版本0.8: REST风格API的建模语言"></a>RAML&trade;版本0.8: REST风格API的建模语言</h1><p>点击查看<a href="http://raml.org/spec.html" target="_blank" rel="external">新版RAML(1.0)</a></p>
<h2 id="u6458_u8981"><a href="#u6458_u8981" class="headerlink" title="摘要"></a>摘要</h2><p>RAML&trade;是一门基于YAML, 用于描述REST风格API的语言. 在<a href="http://yaml.org/spec/1.2/spec.html" target="_blank" rel="external">YAML规范</a>的基础上, 本规范提供了用于描述REST风格API, 创建客户端与服务端代码生成器, 以及通过RAML API定义来生成API用户手册所需的一切信息;</p>
<h2 id="u7B80_u4ECB"><a href="#u7B80_u4ECB" class="headerlink" title="简介"></a>简介</h2><p>本规范介绍了RAML. RAML定义了一种可同时供人阅读与供机器运行的对REST风格API的描述方式. API文档生成器, API客户端代码生成器与API服务器可通过同一份RAML文档分别生成用户手册, 客户端代码以及服务器代码框架.</p>
<h2 id="u7EA6_u5B9A"><a href="#u7EA6_u5B9A" class="headerlink" title="约定"></a>约定</h2><p>本规范中的”<em>必须</em>“, “<em>必须不</em>“, “<em>要求</em>“, “<em>应</em>“, “<em>不应</em>“, “<em>应该</em>“, “<em>不应该</em>“, “<em>建议</em>“, “<em>或许</em>“和”<em>可选</em>“等关键字的意思遵从 RFC 2119 [RFC2119]中的定义.</p>
<h2 id="u6982_u8FF0"><a href="#u6982_u8FF0" class="headerlink" title="概述"></a>概述</h2><p>RAML定义了媒体类型”application/raml+yaml”以用于描述并记录诸如methods, schema等REST风格API的资源. RAML基于YAML语言, 且其文档支持所有YAML 1.2的特性. RAML文件的推荐扩展名是”.raml”.</p>
<p>RAML也提供工具来给REST风格API制作详尽的文档, 并允许文档生成工具从中提取信息来将其转换成诸如PDF, HTML等格式的用户手册.</p>
<p>RAML同样引进了resource types(资源类型)和traits(特质)这两种新概念来描述资源和请求, 以期尽可能减少描述REST风格API时的重复工作.</p>
<p>本RAML规范的结构如下:</p>
<ul>
<li><strong>基础信息.</strong> 说明如何描述一份REST风格API的名字, 标题, 位置等核心方面.</li>
<li><strong>用户手册.</strong> 描述如何为REST风格API引用辅助文档.</li>
<li><strong>Resource Types(资源类型)和Traits(特质).</strong> 描述一种使用RAML的resource types(资源类型)与traits(特质)来避免定义REST风格API时重复工作的技巧.</li>
<li><strong>Resource</strong> 描述如何表示REST风格API中的resources, resources的methods和schema, 以及resources之间的交互.</li>
</ul>
<h3 id="u672F_u8BED"><a href="#u672F_u8BED" class="headerlink" title="术语"></a>术语</h3><p>在本规范中将用 <em>API定义</em> 来表示使用本规范定义的API并用 <em>RAML规范</em> 来表示本文档.</p>
<h3 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h3><p><em>REST</em> 用于形容一个依照REST原则实现的API. REST是Representational State Transfer(表征状态传输)的缩写, 这个概念最早是在2000年时由Roy Fielding在他的博士毕业论文 [REST] 中提出的.</p>
<h3 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h3><p>一个 <em>resource</em> 是对一个实体或是实体组的概念映射.</p>
<h2 id="u6807_u8BB0_u8BED_u8A00"><a href="#u6807_u8BB0_u8BED_u8A00" class="headerlink" title="标记语言"></a>标记语言</h2><p>本规范使用YAML 1.2 [YAML]作为核心格式. 作为可供阅读的数据格式, YAML十分符合本规范的设计目标.</p>
<p>RAML API定义文档像YAML文档一样要求以指明RAML版本的YAML注释行作为起始, 举例如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8</span><br></pre></td></tr></table></figure>
<p>RAML版本必须放在RAML文档的第一行. RAML编译器必须将剩余加了YAML注释符号的行视作注释.</p>
<p>在RAML中, YAML原有的数据结构被增强以容纳原本不支持的数据类型. 所有RAML文档必须支持这些扩展.</p>
<p>在RAML中, 所有值都大小写敏感.</p>
<h3 id="u5F15_u5165"><a href="#u5F15_u5165" class="headerlink" title="引入"></a>引入</h3><p>在YAML规范中不要求YAML编译器使用任何方式把一份YAML文件分成更易管理的小份文件. 而RAML文档必须能够被分为多份文件. 为了支持该功能, 所有RAML编译器必须支持 <em>include</em> 标签来引入RAML, YAML和其他常见文本文件.</p>
<p>在本例中, myTextFile.txt中的内容被引入作为external属性的值.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;external: !include myTextFile.txt</span><br></pre></td></tr></table></figure>
<p>当引入RAML或YAML文件时, RAML编辑器不仅要能够读到其中内容, 还要能将其加入到声明结构中, 就像在文档内声明了这些内容一样.</p>
<p>为了简化API定义, 也由于被引入的文件并不与其父级文件共享编译上下文, 因此一份被引入的文件不应使用另一份文件中定义的锚. 同样地, 父级文件中不应使用引入文件中定义的锚</p>
<p>在本例中, <em>properties.raml</em> 文件定义了两个属性. <em>big.raml</em> 引用了properties.raml文件.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;#properties.raml&#10;&#10;propertyA: valueA&#10;propertyB: valueB</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;#big.raml&#10;&#10;external: !include properties.raml</span><br></pre></td></tr></table></figure>
<p>这样子得到的结果和以下内联声明相同:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;external:&#10;  propertyA: valueA&#10;  propertyB: valueB</span><br></pre></td></tr></table></figure>
<p>如果在被引入的文件中使用了相对路径, 该相对路径会基于原(发起引用的)文件的位置来解读. 如果原文件是作为HTTP资源获取到的, 那么被其引入的文件也应该通过HTTP来获取.</p>
<p>在以下例子中, 由于原(发起引用的)文件位于 <em><a href="http://example-domain.org/api/example.raml" target="_blank" rel="external">http://example-domain.org/api/example.raml</a></em> , 因此 <em>properties.raml</em> 的获取路径应该为 <em><a href="http://example-domain.org/api/properties.raml" target="_blank" rel="external">http://example-domain.org/api/properties.raml</a></em>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;#http://example-domain.org/api/example.raml&#10;&#10;external: !include properties.raml</span><br></pre></td></tr></table></figure>
<p>如果被引入的文件属于以下媒体类型:</p>
<ul>
<li>application/raml+yaml</li>
<li>text/yaml</li>
<li>text/x-yaml</li>
<li>application/yaml</li>
<li>application/x-yaml</li>
</ul>
<p>或者以 <em>.raml</em>, <em>.yml</em>, <em>.yaml</em> 之一作为扩展名时, RAML编译器必须将这些文件中的内容视为RAML并将其加到RAML文档的节点中.</p>
<p>被引入文件的路径, 也就是 !include 右边的内容, 必须是静态的. 也就是说其中不能含有任何resource types(资源类型)或traits(特质)参数. 会考虑在未来版本中加入该功能.</p>
<h2 id="u5177_u540D_u53C2_u6570"><a href="#u5177_u540D_u53C2_u6570" class="headerlink" title="具名参数"></a>具名参数</h2><p>在本RAML规范中为以下属性定义了具名参数集合: URI parameters(统一资源标识符参数), query string parameters(get请求中的请求参数), form parameters(请求体中的表单参数), request bodies(不同媒体类型中的请求体), 以及request and response header(请求头与响应头). 以上属性拥有本章节中定义的所有具名参数.</p>
<p>部分具名参数为可选的, 另一部分为必须的. 具体情况可以看本章节对每个具名参数的描述.</p>
<p>除有特别说明, 所有具名参数的值都应是纯文本. 所有合法的YAML字符也可以被加入到具名参数的值中.</p>
<h3 id="displayName_28_u5C55_u793A_u540D_u79F0_29"><a href="#displayName_28_u5C55_u793A_u540D_u79F0_29" class="headerlink" title="displayName(展示名称)"></a>displayName(展示名称)</h3><p>(可选)<br><em>displayName(展示名称)</em> 属性规定了参数展示的名称. 该值仅在展示或是生成文档时会用到. 如果没有定义, 那么默认会使用参数的名字作为 <em>displayName(展示名称)</em>.</p>
<h3 id="description_28_u63CF_u8FF0_29"><a href="#description_28_u63CF_u8FF0_29" class="headerlink" title="description(描述)"></a>description(描述)</h3><p>(可选)<br><em>description(描述)</em> 属性用于说明参数预期用途或是意义. 其值可以使用 Markdown [Markdown] 格式的文本.</p>
<h3 id="type_28_u7C7B_u578B_29"><a href="#type_28_u7C7B_u578B_29" class="headerlink" title="type(类型)"></a>type(类型)</h3><p>(可选)<br><em>type(类型)</em> 属性规定了参数解析值的基本类型. 若参数的解析值的类型与定义不符合, API客户端必须返回/抛出一个异常. 如果没有定义, 那么默认会以string作为 <em>type(类型)</em>. 合法的类型有:</p>
<table>
<thead>
<tr>
<th style="text-align:left">Type</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">值必须为字符串.</td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">值必须是数, 由YAML定义的浮点数.</td>
</tr>
<tr>
<td style="text-align:left">integer</td>
<td style="text-align:left">值必须是整数. 不允许是整数. integer类型是number类型的一个子集.</td>
</tr>
<tr>
<td style="text-align:left">date</td>
<td style="text-align:left">值必须是一串 RFC2616 [RFC2616] 3.3节中定义的日期格式的字符串. 详见 <a href="/#date-representations">日期表示</a>.</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">值必须是字符串”true”或者”false”(没有双引号)之一.</td>
</tr>
<tr>
<td style="text-align:left">file</td>
<td style="text-align:left">(只适用于表单)<br><br>值必须为一个文件. 客户端生成器应该使用该类型来正确处理文件上传.</td>
</tr>
</tbody>
</table>
<p>#####日期表示</p>
<p>正如[RFC2616]中所定义的, 所有日期/时间戳必须以格林尼治标准时(GMT)表示, 对于HTTP而言GMT完全等同于UTC(协调世界时). 通过把”GMT”缩写加入到日期的时区位置来指定时间类型, 例如: <code>Sun, 06 Nov 1994 08:49:37 GMT</code>.</p>
<h3 id="enum_28_u679A_u4E3E_29"><a href="#enum_28_u679A_u4E3E_29" class="headerlink" title="enum(枚举)"></a>enum(枚举)</h3><p>(可选, 只适用于string类型的参数)<br><em>enum(枚举)</em> 属性会给出参数所有合法值的枚举. 必须通过数组来枚举. 如果定义了 <em>enum(枚举)</em> 属性, API的客户端与服务端都必须验证参数的值是否符合枚举数组中某一项的值. 若数组中没有值匹配得上, 客户端与服务器端都必须将其视为一个错误.</p>
<h3 id="pattern_28_u683C_u5F0F_29"><a href="#pattern_28_u683C_u5F0F_29" class="headerlink" title="pattern(格式)"></a>pattern(格式)</h3><p>(可选, 只适用于string类型的参数)<br><em>pattern(格式)</em> 属性是一个正则表达式, string类型的参数必须与其匹配. 正则表达式的格式必须遵循 ECMA 262/Perl 5. 正则表达式可以使用双引号包裹.</p>
<h3 id="minLength_28_u6700_u5C0F_u957F_u5EA6_29"><a href="#minLength_28_u6700_u5C0F_u957F_u5EA6_29" class="headerlink" title="minLength(最小长度)"></a>minLength(最小长度)</h3><p>(可选, 只适用于string类型的参数)<br><em>minLength(最小长度)</em> 属性规定了参数的值允许的最小字符个数.</p>
<h3 id="maxLength_28_u6700_u5927_u957F_u5EA6_29"><a href="#maxLength_28_u6700_u5927_u957F_u5EA6_29" class="headerlink" title="maxLength(最大长度)"></a>maxLength(最大长度)</h3><p>(可选, 只适用于string类型的参数)<br><em>maxLength(最大长度)</em> 属性规定了参数的值允许的最大字符个数.</p>
<h3 id="minimum_28_u6700_u5C0F_u503C_29"><a href="#minimum_28_u6700_u5C0F_u503C_29" class="headerlink" title="minimum(最小值)"></a>minimum(最小值)</h3><p>(可选, 只适用于number或是integer类型的参数)<br><em>minimum(最小值)</em> 属性规定了参数的最小值.</p>
<h3 id="maximum_28_u6700_u5927_u503C_29"><a href="#maximum_28_u6700_u5927_u503C_29" class="headerlink" title="maximum(最大值)"></a>maximum(最大值)</h3><p>(可选, 只适用于number或是integer类型的参数)<br><em>maximum(最大值)</em> 属性规定了参数的最大值</p>
<h3 id="example_28_u793A_u4F8B_29"><a href="#example_28_u793A_u4F8B_29" class="headerlink" title="example(示例)"></a>example(示例)</h3><p>(可选)<br><em>example(示例)</em> 属性是参数值的一个示例. 文档生成器可以使用该属性来为参数来生成样本值.</p>
<h3 id="repeat_28_u53EF_u91CD_u590D_29"><a href="#repeat_28_u53EF_u91CD_u590D_29" class="headerlink" title="repeat(可重复)"></a>repeat(可重复)</h3><p>(可选)<br><em>repeat(可重复)</em> 属性规定了参数是否能重复使用. 如果能, <em>repeat(可重复)</em> 的值必须设为true. 否则值为false.</p>
<h3 id="required_28_u5FC5_u9700_29"><a href="#required_28_u5FC5_u9700_29" class="headerlink" title="required(必需)"></a>required(必需)</h3><p>(可选, 除非在别处有说明)<br><em>required(必需)</em> 属性规定了参数是否必需出现在API定义中. 若必需则为true, 否则为false.</p>
<p>一般而言, 参数通常是可选的, 除非参数含有 <em>required(必需)</em> 且其值为true.</p>
<p>URI parameters(统一资源标识符参数)的 <em>required(必需)</em> 属性可以省略, 但属性的默认值是true</p>
<h3 id="default_28_u9ED8_u8BA4_u503C_29"><a href="#default_28_u9ED8_u8BA4_u503C_29" class="headerlink" title="default(默认值)"></a>default(默认值)</h3><p>(可选)<br><em>default(默认值)</em> 属性规定了当某个参数被省略或是没有给其赋值时参数的默认值. 这个属性并不是要求客户端在某个参数无值可传时给服务器传一个默认值. 而是要求当客户端没有传来该参数时服务器能将其设为默认值.</p>
<h2 id="u591A_u7C7B_u578B_u5177_u540D_u53C2_u6570"><a href="#u591A_u7C7B_u578B_u5177_u540D_u53C2_u6570" class="headerlink" title="多类型具名参数"></a>多类型具名参数</h2><p>具名参数可以使用map数组作为值来表明该具名参数具有多种类型, 数组中的每一个map都有上文中提到的属性. 这种定义多类型具名参数的机制在API需要给同一个具名参数定义超过一种类型时特别有用.</p>
<p>在下面的例子里具名参数 <em>file</em> 可以用于向API发送一份文件或是字符串文本.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Amazon simple storage API&#10;version: 1&#10;baseUri: https://&#123;destinationBucket&#125;.s3.amazonaws.com&#10;/:&#10;  post:&#10;    description: POST&#25805;&#20316;&#20250;&#20351;&#29992;HTML&#34920;&#21333;&#26469;&#21521;&#23450;&#20041;&#22909;&#30340;&#23481;&#22120;&#20013;&#21152;&#20837;&#19968;&#20010;&#23545;&#35937;.&#10;    body:&#10;      application/x-www-form-urlencoded:&#10;        formParameters:&#10;          AWSAccessKeyId:&#10;            description: &#25480;&#20104;&#21311;&#21517;&#29992;&#25143;&#20351;&#29992;&#21512;&#27861;&#35831;&#27714;&#26435;&#38480;&#30340;&#23481;&#22120;&#25317;&#26377;&#32773;&#30340;AWS Access Key(&#35775;&#38382;&#23494;&#38053;) ID.&#10;            type: string&#10;          acl:&#10;            description: &#35268;&#23450;&#20102;Amazon S3&#30340;&#35775;&#38382;&#25511;&#21046;&#34920;. &#22914;&#26524;&#35775;&#38382;&#25511;&#21046;&#34920;&#20013;&#23450;&#20041;&#20102;&#19968;&#31181;&#38750;&#27861;&#35831;&#27714;, &#37027;&#20040;&#26381;&#21153;&#22120;&#20013;&#20250;&#29983;&#25104;&#19968;&#20010;&#38169;&#35823;&#23545;&#35937;.&#10;            type: string&#10;          file:&#10;            - type: string&#10;              description: &#25991;&#26412;&#20869;&#23481;. &#25991;&#26412;&#20869;&#23481;&#24517;&#39035;&#26159;&#34920;&#21333;&#20013;&#26368;&#21518;&#19968;&#20010;&#23383;&#27573;.&#10;            - type: file&#10;              description: &#19978;&#20256;&#30340;&#25991;&#20214;. &#25991;&#20214;&#24517;&#39035;&#26159;&#34920;&#21333;&#20013;&#26368;&#21518;&#19968;&#20010;&#23383;&#27573;.</span><br></pre></td></tr></table></figure>
<h2 id="u57FA_u7840_u4FE1_u606F"><a href="#u57FA_u7840_u4FE1_u606F" class="headerlink" title="基础信息"></a>基础信息</h2><p>本章节将会介绍RAML API定义中的各个组件.</p>
<h3 id="u6839_u8282_u7EC4"><a href="#u6839_u8282_u7EC4" class="headerlink" title="根节组"></a>根节组</h3><p>根节组中说明了诸如标题, 网页的baseURI以及如何引用公共schema等API的基本信息.</p>
<p>RAML结构的API定义中各项属性出现的顺序可以随意变化.</p>
<p>下面的例子展示了Github v3的RAML API定义中的一部分.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: GitHub API&#10;version: v3&#10;baseUri: https://api.github.com&#10;mediaType:  application/json&#10;schemas:&#10;  - User:  schema/user.json&#10;    Users: schema/users.json&#10;    Org:   schema/org.json&#10;    Orgs:  schema/orgs.json</span><br></pre></td></tr></table></figure>
<h3 id="API_Title_28_u6807_u9898_29"><a href="#API_Title_28_u6807_u9898_29" class="headerlink" title="API Title(标题)"></a>API Title(标题)</h3><p>(必需)<br><em>title(标题)</em> 属性是一段对REST风格API的简单形容. <em>title(标题)</em> 属性的值会被用来作为用户手册的标题.</p>
<h3 id="API_Version_28_u7248_u672C_29"><a href="#API_Version_28_u7248_u672C_29" class="headerlink" title="API Version(版本)"></a>API Version(版本)</h3><p>(可选)<br>如果RAML API定义只针对API的某一个版本, 那么定义中必须包含 <em>version(版本)</em> 属性. <em>version(版本)</em> 属性是可选的, 并且不应使用于在以下情况中:</p>
<ul>
<li>API本身并没有版本.</li>
<li>API的定义不会随着其版本不同而变化. API构建者可以决定是否将对用户手册的修改视作版本变化.</li>
</ul>
<p>只要格式统一, API构建者可以使用任意模式来规定版本. 比如可以使用”v3”, “v3.0”或是”V3”, 但这三个不会被视作同一个版本.</p>
<h3 id="Base_URI_28_u57FAURI_29_u548CbaseUriParameters_28_u57FAURI_u53C2_u6570_29"><a href="#Base_URI_28_u57FAURI_29_u548CbaseUriParameters_28_u57FAURI_u53C2_u6570_29" class="headerlink" title="Base URI(基URI)和baseUriParameters(基URI参数)"></a>Base URI(基URI)和baseUriParameters(基URI参数)</h3><p>(在API设计时为可选; 在API实现时为必需)<br>REST风格API的resources(资源)的定义都基于API的base URI(基URI). 当API还未被实现时是否使用 <em>baseUri(基URI)</em> 属性是可选的. 而当API被实现(即使只是模拟实现)并能在服务器端访问时, 其定义中必需有 <em>baseUri(基URI)</em> 属性. <em>baseUri(基URI)</em> 属性的值必需符合URI规格说明 [RFC2396] 中的定义或者符合 RFC 6570 [RFC6570] 中定义的 Level 1 模板.</p>
<p><em>baseUri(基URI)</em> 属性的值应该仅被视作参考值. API客户端生成器应该能够通过用户的配置来生成 <em>baseUri(基URI)</em>.</p>
<p>如果 <em>baseUri(基URI)</em> 的值是 Level 1 模板, 那么以下为其保留URI参数:</p>
<table>
<thead>
<tr>
<th style="text-align:left">URI参数</th>
<th style="text-align:left">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">version</td>
<td style="text-align:left">version(版本) 属性的值</td>
</tr>
</tbody>
</table>
<p>任何其他出现在 <em>baseUri(基URI)</em> 中的参数都可以定义在根节组的 <em>baseUriParameters(基URI参数)</em> 中. <em>baseUriParameters(基URI参数)</em> 拥有本规范在具名参数章节中定义的所有属性.</p>
<p>如果一个URI模板参数既没有在根节组的 <em>baseUriParameters(基URI参数)</em> 中定义, 也没有在resource-level<br>(资源级) <em>baseUriParameters(基URI参数)</em> 中定义, 它也应被视为一个本规范在具名参数章节中定义的默认参数. 其类型为string, 是必需的, 且展示名称是参数名称.(在去掉了[{]与[}]之后的参数名).</p>
<p>在下面的例子里RAML API定义在 <em>baseUri(基URI)</em> 中使用了 Level 1 模板.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Salesforce Chatter REST API&#10;version: v28.0&#10;baseUri: https://na1.salesforce.com/services/data/&#123;version&#125;/chatter</span><br></pre></td></tr></table></figure>
<p>在下面的例子里使用了定义好的基URI参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Amazon S3 REST API&#10;version: 1&#10;baseUri: https://&#123;bucketName&#125;.s3.amazonaws.com&#10;baseUriParameters:&#10;  bucketName:&#10;    description: &#23481;&#22120;&#30340;&#21517;&#31216;</span><br></pre></td></tr></table></figure>
<h3 id="Protocols_28_u534F_u8BAE_29"><a href="#Protocols_28_u534F_u8BAE_29" class="headerlink" title="Protocols(协议)"></a>Protocols(协议)</h3><p>(可选)<br>一个REST风格API可以通过HTTP或者HTTPS或者能同时通过两个协议访问. <em>protocols协议</em> 属性可以被用来定义API支持的协议. 若没有定义 <em>protocols协议</em> 属性则会默认使用定义在 <em>baseUri(基URI)</em> 中的协议. <em>protocols协议</em> 属性的值必须是string数组, 数组的内容是  <strong>“HTTP”</strong> 和/或 <strong>“HTTPS”</strong>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Salesforce Chatter REST API&#10;version: v28.0&#10;protocols: [ HTTP, HTTPS ]&#10;baseUri: https://na1.salesforce.com/services/data/&#123;version&#125;/chatter</span><br></pre></td></tr></table></figure>
<h3 id="Default_Media_Type_28_u9ED8_u8BA4_u5A92_u4F53_u7C7B_u578B_29"><a href="#Default_Media_Type_28_u9ED8_u8BA4_u5A92_u4F53_u7C7B_u578B_29" class="headerlink" title="Default Media Type(默认媒体类型)"></a>Default Media Type(默认媒体类型)</h3><p>(可选)<br>API responses以及API request body的媒体类型可以通过 <em>mediaType(媒体类型)</em> 属性来定义. 该属性应在API定义的根节组中出现. 属性的值可以是符合以下规则的字符串:</p>
<ul>
<li>以下媒体类型之一:<ul>
<li>text/yaml</li>
<li>text/x-yaml</li>
<li>application/yaml</li>
<li>application/x-yaml*</li>
</ul>
</li>
<li>IANA MIME媒体类型中的任意一种, <a href="http://www.iana.org/assignments/media-types" target="_blank" rel="external">http://www.iana.org/assignments/media-types</a></li>
<li>符合正则表达式<code>application\/[A-Za-z\.-0-1]*\+?(json|xml)</code>的自定义媒体类型</li>
</ul>
<p>对于API resource中的某个operation(method)而言, 如果某一种媒体类型作为key定义在了 <em>body(请求体)</em> 属性中, 或者在 <em>mediaType(媒体类型)</em> 属性中定义了某种媒体类型, 那么 <em>body(请求体)</em> 必须是定义好的媒体类型. 此外, 如果客户端发送的request的Accept header中含有多个API定义中规定媒体类型, 那么服务器应该使用Accept header中的媒体类型作为response的body.</p>
<p>在下面的例子中API只接受与返回JSON格式的body.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Stormpath REST API&#10;version: v1&#10;baseUri: https://api.stormpath.com/&#123;version&#125;&#10;mediaType: application/json</span><br></pre></td></tr></table></figure>
<h3 id="Schemas_28_u6A21_u5F0F_29"><a href="#Schemas_28_u6A21_u5F0F_29" class="headerlink" title="Schemas(模式)"></a>Schemas(模式)</h3><p>(可选)<br>为了让文档内容保持简洁与一致, API定义应该在根节组中使用一个可选的 <em>schemas(模式)</em> 属性. <em>schemas(模式)</em> 属性规定了一组可以用于文档中任意位置的schema. <em>schemas(模式)</em> 属性的值是map数组; 每个map的键都是schema的名字, 值是schema的定义. schema的定义可以写在文档中, 也可以通过RAML的!include来引用外部文件.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;baseUri: https://api.example.com&#10;title: FileSystem API&#10;version: 0.1&#10;schemas:&#10;  - !include (schema&#30340;&#29238;&#30446;&#24405;)/canonicalSchemas.raml&#10;  - File:       !include (schema&#30340;&#29238;&#30446;&#24405;)/filesystem/file.xsd&#10;    FileUpdate: !include (schema&#30340;&#29238;&#30446;&#24405;)/filesystem/fileupdate.xsd&#10;    Files:      !include (schema&#30340;&#29238;&#30446;&#24405;)/filesystem/files.xsd&#10;    Dir:        !include (schema&#30340;&#29238;&#30446;&#24405;)/filesystem/dir.xsd&#10;    Dirs:       !include (schema&#30340;&#29238;&#30446;&#24405;)/filesystem/dirs.xsd&#10;/files:&#10;  get:&#10;    responses:&#10;      200:&#10;        body:&#10;          application/xml:&#10;            schema: Files</span><br></pre></td></tr></table></figure>
<h3 id="URI_Parameters_28URI_u53C2_u6570_29"><a href="#URI_Parameters_28URI_u53C2_u6570_29" class="headerlink" title="URI Parameters(URI参数)"></a>URI Parameters(URI参数)</h3><p>(可选)<br>除了在 <em>baseUri(基URI)</em> 小节中提到过的保留参数之外, 在 Level 1 模板中还可以使用定制的参数以便能应用于多种场景中. 比如说, 在下例中API使用了参数在其基URI中表示公司名称.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: FreshBooks API&#10;version: 2.1&#10;baseUri: https://&#123;companyName&#125;.freshbooks.com/api/&#123;version&#125;/xml-in</span><br></pre></td></tr></table></figure>
<p>URI参数可以在 <em>uriParameters(URI参数)</em> 属性中做更为深入的定义. API定义中不强制要求使用 <em>uriParameters(URI参数)</em>. 但如果使用了, <em>uriParameters(URI参数)</em> 属性的值必须是一个map, 且其中所有的键必须是在 <em>baseUri(基URI)</em> 中出现过的参数的参数名. 键的名称不能是 <em>version</em> , 因为它是保留参数的参数名. 每一个键对应的值是一个map, map中定义了参数的属性, 属性的定义方式可以参照<a href="/#named-parameters">具名参数章节</a>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Salesforce Chatter Communities REST API&#10;version: v28.0&#10;baseUri: https://&#123;communityDomain&#125;.force.com/&#123;communityPath&#125;&#10;uriParameters:&#10; communityDomain:&#10;   displayName: Community Domain&#10;   type: string&#10; communityPath:&#10;   displayName: Community Path&#10;   type: string&#10;   pattern: ^[a-zA-Z0-9][-a-zA-Z0-9]*$&#10;   minLength: 1</span><br></pre></td></tr></table></figure>
<h3 id="User_Documentation_28_u7528_u6237_u624B_u518C_29"><a href="#User_Documentation_28_u7528_u6237_u624B_u518C_29" class="headerlink" title="User Documentation(用户手册)"></a>User Documentation(用户手册)</h3><p>(可选)<br>在API定义中可以使用多份文档来作为API的用户指南或是参考资料. 这类文档可以用于向使用者说明API的功能或是提供业务背景.</p>
<p>文档生成器必须在生成的文档中按照顺序逐份加入 <em>documentation(手册)</em> 属性中的每一份文档.</p>
<p>可以通过在API定义的根节组中加入 <em>documentation(手册)</em> 属性的方式来为API添加用户手册. <em>documentation(手册)</em> 属性必须是文档数组. 每一份文档都必须有 <em>title(标题)</em> 和 <em>content(内容)</em> 属性, 必须要有. 定义的 <em>documentation(手册)</em> 属性中必须至少有一份文档.</p>
<p>文档生成器必须将文档的内容视作 Markdown [MARKDOWN] 格式来处理.</p>
<p>在下面的例子中展示了一个含有一份文档的API.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: ZEncoder API&#10;baseUri: https://app.zencoder.com/api&#10;documentation:&#10; - title: &#39318;&#39029;&#10;   content: |&#10;     Welcome to the _Zencoder API_ Documentation. The _Zencoder API_&#10;     allows you to connect your application to our encoding service&#10;     and encode videos without going through the web  interface. You&#10;     may also benefit from one of our&#10;     [integration libraries](https://app.zencoder.com/docs/faq/basics/libraries)&#10;     for different languages.</span><br></pre></td></tr></table></figure>
<p><em>documentation(手册)</em> 属性中的内容可以放在API定义中, 比如以上例子, 也可以使用RAML的!include来引用外部文件.</p>
<p>在下面展示了同一份API定义(ZEncoder API), 但是其 <em>documentation(手册)</em> 属性的 <em>content(内容)</em> 引用了外部文件.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: ZEncoder API&#10;baseUri: https://app.zencoder.com/api&#10;documentation:&#10; - title: &#39318;&#39029;&#10;   content: !include zencoder-home.md</span><br></pre></td></tr></table></figure>
<p>在RAML API定义中不限制手册的页数. 但如果 <em>documentation(手册)</em> 属性的 <em>content(内容)</em> 过于庞大会使用API定义变得难以阅读, 因此在这种情况下应使用RAML的!include而不是将手册的内容放在API定义中.</p>
<p>在下面的例子中展示了含有多份手册的RAML API定义.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: GitHub API&#10;version: v3&#10;baseUri: https://api.github.com&#10;documentation:&#10; - title: &#20837;&#38376;&#25351;&#21335;&#10;   content: !include github-3-getting-started.md&#10; - title: &#36523;&#20221;&#39564;&#35777;&#22522;&#30784;&#10;   content: !include github-3-basics-of-authentication.md&#10; - title: &#21576;&#29616;&#25968;&#25454;&#22270;&#34920;&#10;   content: !include github-3-rendering-data-as-graphs.md</span><br></pre></td></tr></table></figure>
<h3 id="Resources_and_Nested_Resources_28_u8D44_u6E90_u4E0E_u5D4C_u5957_u8D44_u6E90_29"><a href="#Resources_and_Nested_Resources_28_u8D44_u6E90_u4E0E_u5D4C_u5957_u8D44_u6E90_29" class="headerlink" title="Resources and Nested Resources(资源与嵌套资源)"></a>Resources and Nested Resources(资源与嵌套资源)</h3><p>Resources通过它们的相对URI来区分, 相对URI必须以斜杠(/)作为起始.</p>
<p>一个定义在根节组中的resource被称为 <em>top-level resource(顶级资源)</em>. 其键是resource相对于基URI的URI. 定义在其他resource之下的resource被称为 <em>nested resource(嵌套资源)</em>, 其键是相对于其父resource的URI.</p>
<p>在下面的例子中展示了一个顶级资源/gist以及一个嵌套资源/public</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: GitHub API&#10;version: v3&#10;baseUri: https://api.github.com&#10;/gists:&#10;  displayName: Gists&#10;  /public:&#10;    displayName: Public Gists</span><br></pre></td></tr></table></figure>
<p>每一个或定义在根节组中或定义在其他resource属性之下, 且以斜杠(/)为起始的属性都应被视为resource属性. resource的键可以由多个通过斜杠(/)连接的URI片段组成; 比如说”/bom/items”可以用作一个resource的键. 然而如果其中某个URI片段本身就是一个resource, API定义应该使用嵌套的方式来表示这种结构. 例如, 如果”/bom”是一个资源, 那么”/items”应该表示为”/bom”的一个嵌套资源, 而不是使用”/bom/items”来表示.</p>
<h4 id="Display_Name_28_u5C55_u793A_u540D_u79F0_29"><a href="#Display_Name_28_u5C55_u793A_u540D_u79F0_29" class="headerlink" title="Display Name(展示名称)"></a>Display Name(展示名称)</h4><p><em>displayName(展示名称)</em> 为resource提供了一个名称, 该名称会在生成文档时用到. <em>displayName(展示名称)</em> 是可选的.</p>
<p>如果在一个resource中没有定义 <em>displayName(展示名称)</em>, 那么文档生成器应该使用resource的键(比如说”/jobs”)来作为resource的名称</p>
<h4 id="Description_28_u63CF_u8FF0_29"><a href="#Description_28_u63CF_u8FF0_29" class="headerlink" title="Description(描述)"></a>Description(描述)</h4><p>无论是顶级资源或是嵌套资源都可以用 <em>description(描述)</em> 属性来简单描述resource. 推荐API定义中所有的resource都要有 <em>description(描述)</em> 属性.</p>
<h4 id="Template_URIs_and_URI_Parameters_28_u6A21_u677FURI_u4E0EURI_u53C2_u6570_29"><a href="#Template_URIs_and_URI_Parameters_28_u6A21_u677FURI_u4E0EURI_u53C2_u6570_29" class="headerlink" title="Template URIs and URI Parameters(模板URI与URI参数)"></a>Template URIs and URI Parameters(模板URI与URI参数)</h4><p>如果resource的相对URI中有参数, 那么可以使用含有URI参数的模板URI来定义其相对URI.</p>
<p>在下面的例子中展示了一个键为 <em>/jobs</em> 的顶级资源和一个键为 <em>/{jobId}</em> 的嵌套资源:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: ZEncoder API&#10;version: v2&#10;baseUri: https://app.zencoder.com/api/&#123;version&#125;&#10;/jobs: # its fully-resolved URI is https://app.zencoder.com/api/&#123;version&#125;/jobs&#10;  displayName: Jobs&#10;  description: &#24037;&#20316;&#30340;&#38598;&#21512;&#10;  /&#123;jobId&#125;: # its fully-resolved URI is https://app.zencoder.com/api/&#123;version&#125;/jobs/&#123;jobId&#125;&#10;    description: &#26576;&#19968;&#31181;&#24037;&#20316;, &#24037;&#20316;&#38598;&#21512;&#20013;&#30340;&#19968;&#39033;.</span><br></pre></td></tr></table></figure>
<p>为防止歧义, URI参数中不能含有斜杠(/). 以上面的ZEncoder API为例, “/jobs/123”与嵌套在”/jobs” resource下的”/{jobId}” resource相匹配, 但”/jobs/123/x”不匹配示例API中的任何资源.</p>
<p>一个resource可以用 <em>uriParameters(URI参数)</em> 属性来定义resource中的相关参数, 用法参照具名参数章节. 下面的例子展示了两个顶级资源(/user和/users)和一个用模板URI定义的嵌套资源, “/{userId}”. URI参数”userId”在API中有显式定义, 它的展示名称是”User ID”, 类型是integer.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: GitHub API&#10;version: v3&#10;baseUri: https://api.github.com&#10;/user:&#10;  displayName: Authenticated Use r&#10;/users:&#10;  displayName: Users&#10;  /&#123;userId&#125;:&#10;   displayName: User&#10;   uriParameters:&#10;     userId:&#10;       displayName: User ID&#10;       type: integer</span><br></pre></td></tr></table></figure>
<p>如果出现在resource相对URI中的URI参数没有被显式定义过, 那么它必须被当做具名参数章节中提到过的默认参数. 其类型为string, 是必需的, 且其展示名称是参数名.(在去掉了[{]与[}]之后的参数名). 在下面的例子里, 顶级资源有”folderId”与”fileId”两个URI参数.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Flat Filesystem API&#10;version: v1&#10;/files:&#10;  description: &#25152;&#26377;&#25991;&#20214;&#30340;&#19968;&#20010;&#38598;&#21512;&#10;  /folder_&#123;folderId&#125;-file_&#123;fileId&#125;:&#10;    description: &#25991;&#20214;&#38598;&#21512;&#20013;&#30340;&#19968;&#20221;&#25991;&#20214;</span><br></pre></td></tr></table></figure>
<p><em>mediaTypeExtension(媒体类型扩展)</em> 是URI参数中的一个保留参数. 它可以在URI参数中有显式定义, 也可以没有. 但其含义一定是: 一个被client用来规定request body与response body的媒体类型的参数. 为方便起见, .json等同于Accept header中的application/json, .xml等同于Accept header中的text/xml. 如果resource中使用了该参数, client可以在URI中指定request/response的媒体类型, 而不需要在Accept HTTP header中指定. 在下面的例子中, /user resource中request/response的媒体类型可以是application/json或text/xml:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: API Using media type in the URL&#10;version: v1&#10;/users&#123;mediaTypeExtension&#125;:&#10;  uriParameters:&#10;    mediaTypeExtension:&#10;      enum: [ .json, .xml ]&#10;      description: &#20351;&#29992;.json&#26469;&#25351;&#23450;application/json&#25110;&#29992;.xml&#26469;&#25351;&#23450;text/xml</span><br></pre></td></tr></table></figure>
<p>虽然URI参数可以通过 <em>required(必需)</em> 属性来显式的定义成可选参数, 但如果URI参数两边都有斜杠(“/“), 那么它应该被定义成必需的. 比如说如果”…/{objectId}/…”中的{objectId}是可选的, 那么就URI就可能是”…//…”, 而这是没有意义的. 因此, 只有当URI参数与其他文本相邻时才能被定义为可选. 比如”/people/~{fieldSelectors}”中的{fieldSelectors}可以被定义为可选, 且这表明在API中”/people/~”是一个合法的相对URI.</p>
<h4 id="Base_URI_parameters_28_u57FAURI_u53C2_u6570_29"><a href="#Base_URI_parameters_28_u57FAURI_u53C2_u6570_29" class="headerlink" title="Base URI parameters(基URI参数)"></a>Base URI parameters(基URI参数)</h4><p>Resource或者method可以重写 <em>baseUri(基URI)</em> 模板的值. 这在约束或改变默认的基URI参数或是在对其做参数筛选时很有用. 每一个resource中的 <em>baseUriParameters(基URI参数)</em> 属性可以重写部分或者全部根节组 <em>baseUriParameters(基URI参数)</em> 中显式定义的参数. 也可以重写没有显式定义的参数.</p>
<p>在下面的例子里, 必须通过”<a href="https://api-content.dropbox.com/{version}&quot;来调用/files" target="_blank" rel="external">https://api-content.dropbox.com/{version}&quot;来调用/files</a>, 而API中其他的resources则需通过”<a href="https://api.dropbox.com/{version}&quot;来调用" target="_blank" rel="external">https://api.dropbox.com/{version}&quot;来调用</a>.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Dropbox API&#10;version: 1&#10;baseUri: https://&#123;apiDomain&#125;.dropbox.com/&#123;version&#125;&#10;baseUriParameters:&#10;  apiDomain:&#10;    description: |&#10;      API&#25152;&#22312;&#30340;&#23376;&#22495;&#21517;. &#32477;&#22823;&#22810;&#25968;&#35843;&#29992;API&#30340;&#35831;&#27714;&#37117;&#20250;&#21457;&#21521;https://api.dropbox.com&#10;    enum: [ &#34;api&#34; ]&#10;/account/info:&#10;  displayName: Account Information&#10;/files:&#10;  displayName: Download files&#10;  baseUriParameters:&#10;    apiDomain:&#10;      enum: [ &#34;api-content&#34; ]</span><br></pre></td></tr></table></figure>
<p>在resource的级联结构中, 绝大多数 <em>baseUriParameters(基URI参数)</em> 会完全重写之前基URI参数中的定义. 在下面的例子中<code>/user/{userId}/image</code>重写了<code>/users</code>中的定义.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Users API&#10;version: 1&#10;baseUri: https://&#123;apiDomain&#125;.someapi.com&#10;/users:&#10;  displayName: retrieve all users&#10;  baseUriParameters:&#10;    apiDomain:&#10;      enum: [ &#34;api&#34; ]&#10;  /&#123;userId&#125;/image:&#10;    displayName: access users pictures&#10;    baseUriParameters:&#10;      apiDomain:&#10;        enum: [ &#34;static&#34; ]</span><br></pre></td></tr></table></figure>
<p>在下面的例子中, <code>PUT</code> method重写了<code>/user/{userId}/image</code>中的定义.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: Users API&#10;version: 1&#10;baseUri: https://&#123;apiDomain&#125;.someapi.com&#10;/users:&#10;  displayName: retrieve all users&#10;  baseUriParameters:&#10;    apiDomain:&#10;      enum: [ &#34;api&#34; ]&#10;  /&#123;userId&#125;/image:&#10;    displayName: access users pictures&#10;    baseUriParameters:&#10;      apiDomain:&#10;        enum: [ &#34;static&#34; ]&#10;    get:&#10;      displayName: retrieve a user&#39;s picture&#10;    put:&#10;      displayName: update a user&#39;s picture&#10;      baseUriParameters:&#10;        apiDomain:&#10;          enum: [ &#34;content-update&#34; ]</span><br></pre></td></tr></table></figure>
<p><em>version(版本)</em> 是保留属性. 处理程序必须将任意一个基URI中的{version}替换成根节组中定义的 <em>version(版本)</em> 属性. 如果在基URI中使用了{version}参数, 那么它就是必需的: 如果在基URI中出现过, 根节组中必须出现 <em>version(版本)</em> 属性且值必须是合法非空的URI片段.</p>
<h4 id="Absolute_URI_28_u7EDD_u5BF9URI_29"><a href="#Absolute_URI_28_u7EDD_u5BF9URI_29" class="headerlink" title="Absolute URI(绝对URI)"></a>Absolute URI(绝对URI)</h4><p>绝对URI不会被显式定义. 它们会通过绝对路径, 顶级资源的相对路径以及一层层嵌套资源的相对路径依次相加计算得到.</p>
<p>举前一个例子来说, public gist的绝对URI通过以下方式构成:</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="string">"https://api.github.com"</span>               &lt;-<span class="comment">-- 基URI</span></span><br><span class="line">               +</span><br><span class="line">             <span class="string">"/gists"</span>                     &lt;-<span class="comment">-- gists resource 的相对URI</span></span><br><span class="line">               +</span><br><span class="line">             <span class="string">"/public"</span>                    &lt;-<span class="comment">-- public gists resource 的相对URI</span></span><br><span class="line">               =</span><br><span class="line"><span class="string">"https://api.github.com/gists/public"</span>     &lt;-<span class="comment">-- public gists 的绝对URI</span></span><br></pre></td></tr></table></figure>
<p>一个嵌套资源本身可以有子嵌套资源.</p>
<p>在下面的例子中, /user是一个没有子资源的顶级资源; /users是有一个子嵌套资源/{userId}的顶级资源; 而嵌套资源/{userId}有三个子嵌套资源, 分别是/followers, /following和/keys.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: GitHub API&#10;version: v3&#10;baseUri: https://api.github.com&#10;/user:&#10;/users:&#10;  /&#123;userId&#125;:&#10;    uriParameters:&#10;      userId:&#10;        type: integer&#10;    /followers:&#10;    /following:&#10;    /keys:&#10;      /&#123;keyId&#125;:&#10;        uriParameters:&#10;          keyId:&#10;            type: integer</span><br></pre></td></tr></table></figure>
<p>这些资源的绝对URI按顺序分别为:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">https:</span><span class="comment">//api.github.com/user</span></span><br><span class="line"><span class="string">https:</span><span class="comment">//api.github.com/users</span></span><br><span class="line"><span class="string">https:</span><span class="comment">//api.github.com/users/&#123;userId&#125;</span></span><br><span class="line"><span class="string">https:</span><span class="comment">//api.github.com/users/&#123;userId&#125;/followers</span></span><br><span class="line"><span class="string">https:</span><span class="comment">//api.github.com/users/&#123;userId&#125;/following</span></span><br><span class="line"><span class="string">https:</span><span class="comment">//api.github.com/users/&#123;userId&#125;/keys</span></span><br><span class="line"><span class="string">https:</span><span class="comment">//api.github.com/users/&#123;userId&#125;/keys/&#123;keyId&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="Methods_28_u65B9_u6CD5_29"><a href="#Methods_28_u65B9_u6CD5_29" class="headerlink" title="Methods(方法)"></a>Methods(方法)</h4><p>在REST风格API中, <em>methods(方法)</em> 是对资源的操作. Method必须是HTTP版本1.1规约 [RFC2616] 以及其扩展 RFC5789 [RFC5789]中所定义的方法之一.</p>
<h5 id="Description_28_u63CF_u8FF0_29-1"><a href="#Description_28_u63CF_u8FF0_29-1" class="headerlink" title="Description(描述)"></a>Description(描述)</h5><p>每一个声明的method中都可以有 <em>description(描述)</em> 属性来对method将会如何操作资源作简短描述. 推荐给API中的每一个method都加上 <em>description(描述)</em> 属性.</p>
<p>以下API展示了一个声明了GET与POST method的资源/jobs:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: ZEncoder API&#10;version: v2&#10;baseUri: https://app.zencoder.com/api/&#123;version&#125;&#10;/jobs:&#10;  post:&#10;    description: &#21019;&#24314;&#19968;&#20010;Job&#10;  get:&#10;    description: &#33719;&#21462;Jobs&#30340;&#21015;&#34920;</span><br></pre></td></tr></table></figure>
<p><em>description(描述)</em> 属性的值可以是  Markdown [MARKDOWN] 格式的文本.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: ZEncoder API&#10;version: v2&#10;baseUri: https://app.zencoder.com/api/&#123;version&#125;&#10;/jobs:&#10;  post:&#10;    description: |&#10;      Post body&#20013;&#24517;&#39035;&#21547;&#26377;&#35270;&#39057;&#30340;_URL_&#20197;&#20379;&#22788;&#29702;. &#20854;&#20013;&#20063;&#21487;&#20197;&#26377;&#36755;&#20986;&#36335;&#24452;,&#10;      &#25552;&#31034;&#35774;&#32622;&#21644;&#36716;&#30721;&#35774;&#32622;&#36825;&#19977;&#39033;&#36755;&#20986;&#35774;&#32622;.&#10;&#10;      &#25105;&#20204;&#29616;&#22312;&#25903;&#25345;&#20351;&#29992;HTTP/HTTPS, S3, &#20113;&#25991;&#20214;, FTP/FTPS, SFTP&#21644;&#10;      Aspera&#21327;&#35758;&#26469;&#19979;&#36733;&#25991;&#20214;.&#10;      &#24403;&#20320;&#36890;&#36807;API&#21019;&#24314;&#20102;&#19968;&#20010;&#26032;&#30340;&#36716;&#30721;job&#26102;, &#25105;&#20204;&#30340;&#26381;&#21153;&#22120;&#20250;&#31435;&#21363;&#36820;&#22238;job&#10;      &#30340;&#32454;&#33410;&#20197;&#21450;&#36755;&#20986;&#25991;&#20214;. &#20320;&#24212;&#35813;&#23558;job&#21644;&#36755;&#20986;&#30340;ID&#20648;&#23384;&#36215;&#26469;&#20197;&#20415;&#36861;&#36394;&#36716;&#30721;&#10;      &#36807;&#31243;.</span><br></pre></td></tr></table></figure>
<h5 id="Headers"><a href="#Headers" class="headerlink" title="Headers"></a>Headers</h5><p>API中的methods可能得支持或者需要非标准的HTTP header. 在API定义中可以通过 <em>headers</em> 属性来定义这些HTTP header.</p>
<p><em>headers</em> 属性的值是map, 键为HTTP header的名字, 每一个键的值也是map, 其中的各个属性可以参照<a href="/#name-parameters">具名参数章节</a>.</p>
<p>下面的例子展示了有一个HTTP header的POST method.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: ZEncoder API&#10;version: v2&#10;baseUri: https://app.zencoder.com/api/&#123;version&#125;&#10;/jobs:&#10;  post:&#10;    description: &#21019;&#24314;Job&#10;    headers:&#10;      Zencoder-Api-Key:&#10;        displayName: ZEncoder API Key</span><br></pre></td></tr></table></figure>
<p>如果header名称中有占位符{*}, 那么{*}可以被0个或任意多个合法header字符所替代. 而处理程序必须支持这类格式的header, 无论符合格式的header有多少种. 处理程序也应提供实现添加任意多种该格式header的方法. 这对那些允许拥有定制命名规约的HTTP header发送定制数据的API十分有用.</p>
<p>在下面的例子中, header x-metadata-{*} 发送会随job一起被储存的元数据.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#%RAML 0.8&#10;title: ZEncoder API&#10;version: v2&#10;baseUri: https://app.zencoder.com/api/&#123;version&#125;&#10;/jobs:&#10;  post:&#10;    description: &#21019;&#24314;Job&#10;    headers:&#10;      Zencoder-Api-Key:&#10;        displayName: ZEncoder API Key&#10;      x-Zencoder-job-metadata-&#123;*&#125;&#10;        displayName: Job Metadata&#10;        description: |&#10;           Field names prefixed with x-Zencoder-job-metadata- contain user-specified metadata.&#10;           The API does not validate or use this data. All metadata headers will be stored&#10;           with the job and returned to the client when this resource is queried.</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/08/raml-0-8中文版/" data-id="cijo6u6j30001nf7jgees1k6f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/05/hello-world/" class="article-date">
  <time datetime="2016-01-05T04:10:49.000Z" itemprop="datePublished">2016-01-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/05/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start"><a href="#Quick_Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create_a_new_post"><a href="#Create_a_new_post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server"><a href="#Run_server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files"><a href="#Generate_static_files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites"><a href="#Deploy_to_remote_sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/05/hello-world/" data-id="cijo6u6iw0000nf7jsmuj0xmi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/08/raml-0-8中文版/">raml-0.8中文版</a>
          </li>
        
          <li>
            <a href="/2016/01/05/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 PilockHulmes<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>